package com.example.depanalysis.analysis;

import com.example.depanalysis.dto.VulnerabilityInfo;
import com.example.depanalysis.dto.VulnerabilityResult;
import com.example.depanalysis.util.JarMetadataExtractor;
import com.example.depanalysis.util.JarUtils;
import com.example.depanalysis.util.OsvClient;
import com.example.depanalysis.util.DependencyExtractor;
import com.fasterxml.jackson.databind.JsonNode;
import java.nio.file.Path;
import java.util.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

@Component
public class OSVJarVulnerabilityChecker implements JarVulnerabilityChecker {
    private static final Logger logger = LoggerFactory.getLogger(OSVJarVulnerabilityChecker.class);

    @Override
    public List<VulnerabilityResult> checkVulnerabilities(Path projectDir) {
        logger.info("Starting vulnerability check for project directory: {}", projectDir);
        List<VulnerabilityResult> results = new ArrayList<>();
        Set<String> seen = new HashSet<>();

        // 1. Process all JARs (including lib/)
        logger.info("Step 1: Processing JAR files");
        List<Path> jars = JarUtils.findAllJars(projectDir);
        logger.info("Found {} JAR files to analyze", jars.size());

        for (Path jar : jars) {
            logger.debug("Processing JAR file: {}", jar.getFileName());
            Optional<Map<String, String>> mavenCoords = JarMetadataExtractor.extractMavenCoordinates(jar);
            
            if (mavenCoords.isPresent()) {
                Map<String, String> coords = mavenCoords.get();
                String groupId = coords.get("groupId");
                String artifactId = coords.get("artifactId");
                String version = coords.get("version");
                String key = groupId + ":" + artifactId + ":" + version;
                if (seen.add(key)) {
                    logger.debug("Checking vulnerabilities for JAR dependency: {}", key);
                    results.addAll(checkMavenCoords(groupId, artifactId, version, jar.getFileName().toString()));
                } else {
                    logger.debug("Skipping duplicate dependency from JAR: {}", key);
                }
            } else {
                // Create a result entry for JARs without Maven coordinates
                logger.warn("Could not extract Maven coordinates from JAR: {}", jar.getFileName());
                VulnerabilityResult result = new VulnerabilityResult();
                result.setJarName(jar.getFileName().toString());
                result.setGroupId("UNKNOWN");
                result.setArtifactId("UNKNOWN");
                result.setVersion("UNKNOWN");
                result.setVulnerabilities(new ArrayList<>()); // Empty list, cannot check vulnerabilities
                results.add(result);
                logger.debug("Added result entry for JAR without Maven coordinates: {}", jar.getFileName());
            }
        }

        // 2. Parse all pom.xml files recursively
        logger.info("Step 2: Processing all pom.xml dependencies in project and submodules");
        List<Path> pomFiles = DependencyExtractor.findAllPomXmls(projectDir);
        for (Path pom : pomFiles) {
            logger.info("Parsing dependencies from pom.xml: {}", pom);
            List<Map<String, String>> mavenDeps = DependencyExtractor.parsePomXml(pom);
            logger.info("Found {} dependencies in {}", mavenDeps.size(), pom);
            for (Map<String, String> dep : mavenDeps) {
                String groupId = dep.get("groupId");
                String artifactId = dep.get("artifactId");
                String version = dep.get("version");
                String key = groupId + ":" + artifactId + ":" + version;
                if (seen.add(key)) {
                    logger.debug("Checking vulnerabilities for pom.xml dependency: {}", key);
                    results.addAll(checkMavenCoords(groupId, artifactId, version, pom.toString()));
                } else {
                    logger.debug("Skipping duplicate dependency from pom.xml: {}", key);
                }
            }
        }

        // 3. Parse all build.gradle files recursively
        logger.info("Step 3: Processing all build.gradle dependencies in project and submodules");
        List<Path> gradleFiles = DependencyExtractor.findAllBuildGradleFiles(projectDir);
        for (Path gradlePath : gradleFiles) {
            logger.info("Parsing dependencies from build.gradle: {}", gradlePath);
            List<Map<String, String>> gradleDeps = DependencyExtractor.parseBuildGradle(gradlePath);
            logger.info("Found {} dependencies in {}", gradleDeps.size(), gradlePath);
            for (Map<String, String> dep : gradleDeps) {
                String groupId = dep.get("groupId");
                String artifactId = dep.get("artifactId");
                String version = dep.get("version");
                String key = groupId + ":" + artifactId + ":" + version;
                if (seen.add(key)) {
                    logger.debug("Checking vulnerabilities for build.gradle dependency: {}", key);
                    results.addAll(checkMavenCoords(groupId, artifactId, version, gradlePath.toString()));
                } else {
                    logger.debug("Skipping duplicate dependency from build.gradle: {}", key);
                }
            }
        }

        logger.info("Vulnerability check completed. Found {} vulnerabilities across {} unique dependencies.",
                results.stream().mapToInt(r -> r.getVulnerabilities() != null ? r.getVulnerabilities().size() : 0).sum(), seen.size());
        logger.info("Total vulnerability results generated: {}", results.size());
        return results;
    }

    private List<VulnerabilityResult> checkMavenCoords(String groupId, String artifactId, String version, String source) {
        logger.debug("Querying OSV API for {}:{}:{} from source: {}", groupId, artifactId, version, source);
        List<VulnerabilityResult> results = new ArrayList<>();
        try {
            JsonNode osvResp = OsvClient.queryMaven(groupId, artifactId, version);
            List<VulnerabilityInfo> vulns = new ArrayList<>();
            if (osvResp.has("vulns")) {
                for (JsonNode vuln : osvResp.get("vulns")) {
                    VulnerabilityInfo info = new VulnerabilityInfo();
                    info.setId(vuln.path("id").asText(null));
                    info.setSummary(vuln.path("summary").asText(null));
                    info.setDetails(vuln.path("details").asText(null));
                    // aliases
                    List<String> aliases = new ArrayList<>();
                    if (vuln.has("aliases")) {
                        for (JsonNode alias : vuln.get("aliases")) {
                            aliases.add(alias.asText());
                        }
                    }
                    info.setAliases(aliases);
                    // references
                    List<String> refs = new ArrayList<>();
                    if (vuln.has("references")) {
                        for (JsonNode ref : vuln.get("references")) {
                            refs.add(ref.path("url").asText());
                        }
                    }
                    info.setReferences(refs);
                    // severity
                    List<String> sev = new ArrayList<>();
                    if (vuln.has("severity")) {
                        for (JsonNode s : vuln.get("severity")) {
                            String sevStr = s.path("type").asText();
                            if (s.has("score"))
                                sevStr += " " + s.path("score").asText();
                            sev.add(sevStr);
                        }
                    }
                    info.setSeverity(sev);
                    vulns.add(info);
                }
            }

            if (vulns.isEmpty()) {
                logger.debug("No vulnerabilities found for {}:{}:{}", groupId, artifactId, version);
            } else {
                logger.warn("Found {} vulnerabilities for {}:{}:{} from {}", vulns.size(), groupId, artifactId, version, source);
            }

            VulnerabilityResult result = new VulnerabilityResult();
            result.setJarName(source);
            result.setGroupId(groupId);
            result.setArtifactId(artifactId);
            result.setVersion(version);
            result.setVulnerabilities(vulns);
            results.add(result);

        } catch (Exception e) {
            logger.error("Error checking vulnerabilities for {}:{}:{} ({}): {}", groupId, artifactId, version, source, e.getMessage(), e);
        }
        return results;
    }
}